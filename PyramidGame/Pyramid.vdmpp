class Pyramid
types
	public CardNumber = nat
	   inv n == n <= 52;
	public DeckType = seq of nat1;
	public String = seq of char;
values
-- TODO Define values here
instance variables
	public deck: seq of CardNumber := [];
	public static pyramidDeck: seq of seq of CardNumber := [];
	public static auxDeck: seq of CardNumber := [];
	public validDeck: seq of CardNumber:= [];
	public static selectedCards: seq of seq of nat:= [];
	public static score: int := 0;
	public static selected: int := 0;
	-- Para uso do power set
	public static setExample: set of nat := {};
	public bonusPyramidDeck: bool := true;
	public bonusDeck: bool := true;
	
	
operations
public Pyramid: () ==> Pyramid
	Pyramid() == (createDeck(); createPyramidDeck(); return self);

public game: () ==> ()
	game() == (	

	--getAuxCard();
	updateValidDeck();
	Utils`printStatus();
	
	IO`print("\n");
	IO`print(selectedCard(7,7));
	IO`print("\n");
	updateGame();
	IO`print(selectedCard(7,3));
	IO`print("\n");
	updateGame();	
	
	Utils`printStatus();	
	
	updateGame();	
	
);

 -- Cria deck inicial
public createDeck() ==
(
	deck := [ i | i in set {1, ..., 52}];
);	

-- Cria a Piramide de Cartas
public createPyramidDeck() == (	
	for counter = 0 to 6 do (
		dcl aux : seq of nat1 := [];
		for counter2 = 0 to counter do (
			dcl value: nat1 := getCard(deck);
				aux := [value] ^ aux;							
		);
		pyramidDeck := pyramidDeck ^ [aux];
	);
			-- Para testar o validDeck
			--pyramidDeck := [[1], [2, 3], [4, 5, 6], [7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28]];
);

public updateValidDeck() == (
	for i = 1 to 7 do (
		for j = 1 to i do (
			if checkValidCard(i, j)
				then validDeck := [pyramidDeck(i)(j)] ^ validDeck;
		);
	);
	for i = 1 to len auxDeck do (
		if i < 3 
			then validDeck := [auxDeck(i)] ^ validDeck;
	);
);

public checkValidCard: nat1 * nat1 ==> bool
	checkValidCard(i, j) == (
		if pyramidDeck(i)(j) = 0
			then return false
		else if i = 7
			then return true
		else if pyramidDeck(i+1)(j) = 0 and pyramidDeck(i+1)(j+1) = 0
			then return true
		else
			return false;
);

-- Seleciona carta
public selectedCard: nat * nat1 ==> bool
	selectedCard(i, j) == (
		for counter = 1 to len validDeck do (
			if validDeck(counter) = pyramidDeck(i)(j)
				then (selected := selected + Utils`cardToPoints(pyramidDeck(i)(j));
							selectedCards:= [[i,j]] ^ selectedCards;					
							return true;)
		);
		return false;
);

-- Retira carta do deck auxiliar
public getAuxCard() ==
(	
	dcl value: nat1 := getCard(deck);
	auxDeck := [value] ^ auxDeck;
);

-- Remove carta passada como argumento do deck inicial
public getCard: (DeckType) ==> nat1
	getCard(deckToGet) == (
		dcl position: nat1 := new MATH().rand(len deckToGet) + 1;
		deck := removeCard(deckToGet, position);
		return deckToGet(position);
);
	
public removeCard: DeckType * nat1 ==> DeckType
	removeCard(deckToRemove, position) == (
		return deckToRemove(1, ... , position - 1) ^ deckToRemove(position + 1, ... , len deck);
);

public updateGame: () ==> ()
	updateGame() == (
		if selected = 13
			then (calcScore(); removeSelectedCards(); selected := 0)
		else if selected > 13
			then (selectedCards := []; selected := 0);   
);

-- Traduz regras em pontos
public combo: () ==> nat
	combo() == (
		if (len selectedCards > 2)
			then return ((len selectedCards - 2) * 10)
		else
			 return 0
);

public bonus: () ==> nat
	bonus() == (
		if (bonusPyramidDeck and len pyramidDeck = 0)
			then (bonusPyramidDeck := false; return 50;) 
		else if (bonusDeck and len deck = 0)
			then (bonusDeck := false; return 30;) 
		else
			 return 0
);

public calcScore: () ==> ()
	calcScore() == (
		score := score + ((len selectedCards) * 10) + combo() + bonus();
);


public removeSelectedCards: () ==> ()
	removeSelectedCards() == (
		for i = 1 to len selectedCards do (
			pyramidDeck(selectedCards(i)(1))(selectedCards(i)(2)) := 0;
		);
);
-- Pesquisar se existem as condições necessárias para o jogo continuar
--	- Existir jogadas válias
public continueGame: () ==> bool
	continueGame() == (		
		dcl sumCombination : nat := 0;
		IO`print(power setExample); -- listas das combinações possiveis
	
		-- Combina os elementos da lista exemplo e soma cada sublista
		for all value in set power setExample do ( 
					IO`print("\nCombinação possível: "); 
					IO`print(value);
					IO`print(", Soma: "); 
				  sumCombination := SumSet(value);
					IO`print(sumCombination);
					
					if sumCombination >= 13
						then return true;
				 );
			return false;
);

-- Conversão para score
public getPoints: (nat1) ==> nat1
	getPoints(num) == (
			return num mod 13;
);
	
	
functions

-- Sum Set from structure to single value
-- http://kurser.iha.dk/eit/tivdm1/Quick_Overview_of_VDM_Operators.pdf
public SumSet: set of nat -> nat
	SumSet(s) == (
		if s = {}
			then 0
		else let e in set s
					in
						e + SumSet(s\{e})
	);

	
traces
-- TODO Define Combinatorial Test Traces here
end Pyramid