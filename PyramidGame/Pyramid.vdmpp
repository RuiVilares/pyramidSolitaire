class Pyramid
types
	public CardNumber = nat
	   inv n == n <= 52;
	public DeckType = seq of nat1;
	public String = seq of char;
values
-- TODO Define values here
instance variables
	public deck: seq of CardNumber := [];
	public static pyramidDeck: seq of seq of CardNumber := [];
	public static auxDeck: seq of CardNumber := [];
	public validDeck: seq of CardNumber:= [];
	public static selectedCards: seq of seq of nat:= [];
	public static score: int := 0;
	public static selected: int := 0;
	-- Para uso do power set
	public static setExample: set of nat := {};
	
	
operations
public Pyramid: () ==> Pyramid
	Pyramid() == (createDeck(); createPyramidDeck(); return self);

public game: () ==> ()
	game() == (	

	getAuxCard();

	updateValidDeck();
	IO`print("\n");
	
	Utils`printStatus();		
);

 -- Cria deck inicial
public createDeck() ==
(
	deck := [ i | i in set {1, ..., 52}];
	
);	

-- aceder
/*	for counter = 1 to 3
		do (
			for counter2 = 1 to counter 
				do (		
						IO`print(pyramidDeck(counter)(counter2));
						);
			IO`print("\n");
			);
*/				
-- introduzir
/*	for counter = 1 to 3
		do (
				deck := [counter] ^ deck;
			);
			
	for counter = 1 to 3
		do (
				IO`print(deck(counter));
			);
	*/	

-- Cria a Piramide de Cartas
public createPyramidDeck() ==
(	
	for counter = 0 to 6
		do (
			dcl aux : seq of nat1 := [];
			for counter2 = 0 to counter 
				do (
						dcl value: nat1 := getCard(deck);
						aux := [value] ^ aux;
									
						);
				pyramidDeck := pyramidDeck ^ [aux];
			);
			
			-- Para testar o validDeck
			--pyramidDeck := [[1], [2, 3], [4, 5, 6], [7, 8, 9, 10], [0, 0, 13, 14, 15], [0, 0, 18, 0, 0, 20], [0,0,0,0,0,0,0]];
			
					
		--	IO`print(getPoints(24));
);

public updateValidDeck() ==
(
	for i = 1 to 7 do (
		for j = 1 to i do (
			if checkValidCard(i, j)
				then validDeck := [pyramidDeck(i)(j)] ^ validDeck;
		);
	);
	for i = 1 to len auxDeck do (
		if i < 3 
			then validDeck := [auxDeck(i)] ^ validDeck;
	);
);

public checkValidCard: nat1 * nat1 ==> bool
	checkValidCard(i, j) == (
		if pyramidDeck(i)(j) = 0
			then return false
		else if i = 7
			then return true
		else if pyramidDeck(i+1)(j) = 0 and pyramidDeck(i+1)(j+1) = 0
			then return true
		else
			return false;
);

-- Seleciona carta
public selectedCard: nat * nat1 ==> bool
	selectedCard(i, j) == (
		for counter = 1 to len validDeck do (
			if validDeck(counter) = pyramidDeck(i)(j)
				then (selected := selected + Utils`cardToPoints(pyramidDeck(i)(j));
							selectedCards:= [[i,j]] ^ selectedCards;					
							return true;)
		);
		return false;
);

-- Retira carta do deck auxiliar
public getAuxCard() ==
(	
	dcl value: nat1 := getCard(deck);
	auxDeck := [value] ^ auxDeck;
);

-- Remove carta passada como argumento do deck inicial
public getCard: (DeckType) ==> nat1
	getCard(deckToGet) == (
		dcl position: nat1 := new MATH().rand(len deckToGet) + 1;
		deck := removeCard(deckToGet, position);
		return deckToGet(position);
);
	
public removeCard: DeckType * nat1 ==> DeckType
	removeCard(deckToRemove, position) == (
		return deckToRemove(1, ... , position - 1) ^ deckToRemove(position + 1, ... , len deck);
);

public updateGame() ==> ()
	updateGame() == (
		if selected = 13
			then (score 
);

-- Traduz regras em pontos
public move

-- Pesquisar se existem as condições necessárias para o jogo continuar
--	- Existir jogadas válias
public continueGame: () ==> bool
	continueGame() == (		
		dcl sumCombination : nat := 0;
		IO`print(power setExample); -- listas das combinações possiveis
	
		-- Combina os elementos da lista exemplo e soma cada sublista
		for all value in set power setExample
			do ( 
					IO`print("\nCombinação possível: "); 
					IO`print(value);
					IO`print(", Soma: "); 
				  sumCombination := SumSet(value);
					IO`print(sumCombination);
					
					if sumCombination >= 13
						then return true;
				 );
			return false;
);


-- Conversão para score
public getPoints: (nat1) ==> nat1
	getPoints(num) == (
			return num mod 13;
);
	
	
functions

-- Sum Set from structure to single value
-- http://kurser.iha.dk/eit/tivdm1/Quick_Overview_of_VDM_Operators.pdf
public SumSet: set of nat -> nat
	SumSet(s) == (
		if s = {}
			then 0
		else let e in set s
					in
						e + SumSet(s\{e})
	);

	
traces
-- TODO Define Combinatorial Test Traces here
end Pyramid