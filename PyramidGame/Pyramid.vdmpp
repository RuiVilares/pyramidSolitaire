class Pyramid
types
	public CardNumber = nat
	   inv n == n <= 52;
	public DeckType = seq of nat1;
	public String = seq of char;
	public NaturalsNums = seq of nat;
	public NaturalsNumsDiff0 = seq of nat1;

values
-- TODO Define values here
instance variables
	public deck: seq of CardNumber := [];
	public static pyramidDeck: seq of seq of CardNumber := [];
	public static auxDeck: seq of CardNumber := [];
	public validDeck: seq of CardNumber:= [];
	public static selectedCards: seq of NaturalsNums:= [];
	public static score: int := 0;
	public static selected: int := 0;
	public bonusPyramidDeck: bool := true;
	public bonusDeck: bool := true;
	
	
operations
public Pyramid: () ==> Pyramid
	Pyramid() == (
		createDeck();
		createPyramidDeck();
		updateValidDeck();
		Utils`printStatus();
		return self;
	);

public selectCard: nat1 * nat ==> ()
	selectCard(xCoord, yCoord) == (	
		-- Se carta selecionada já tinha sido selecionada, desseleciona-a
		for position = 1 to len selectedCards do (
			if selectedCards(position) = [yCoord,xCoord]
				then deselectCard(selectedCards, position, yCoord, xCoord);
		);
			
		if not selectedCard(yCoord, xCoord) then IO`print("Seleção inválida\n");

		if not continueGame() then IO`print("Perdeste! O jogo terminou por falta de jogadas possíveis.\n");

		if updateGame()
			then (
				updateValidDeck();
				if not continueGame() then IO`print("Perdeste! O jogo terminou por falta de jogadas possíveis.\n"); );
			
		Utils`printStatus();	
	
	-- Verifica se jogo terminou
	IO`print(isFinished());
	-- Verifica se existe jogadas possíveis
	IO`print(continueGame());
);

-- Pesquisar se existem as condições necessárias para o jogo continuar
--	- Existir jogadas válias
public continueGame: () ==> bool
	continueGame() == (	
		dcl sumCombination : nat := 0;
		dcl setValidDeck: set of CardNumber:= elems validDeck;
		
		if isFinished()
			then (IO`print("Parabéns! Ganhaste o jogo! O teu score é "); IO`print(score););
		if len deck > 0
			then return true;
			
		-- Combina os elementos da lista exemplo e soma cada sublista
		for all value in set power setValidDeck do ( 
			sumCombination := SumSet(value);
			 if sumCombination >= 13
				then return true;
		);
		return false;
);

 -- Cria deck inicial
public createDeck() ==
(
	deck := [ i | i in set {1, ..., 52}];
);	

-- Piramide de Cartas
-- Cria a Piramide de Cartas
public createPyramidDeck() == (	
	for counter = 0 to 6 do (
		dcl aux : NaturalsNumsDiff0 := [];
		for counter2 = 0 to counter do (
			dcl value: nat1 := getCard(deck);
				aux := [value] ^ aux;							
		);
		pyramidDeck := pyramidDeck ^ [aux];
	);
			-- Para testar o validDeck
			--pyramidDeck := [[1], [2, 3], [4, 5, 6], [7, 8, 9, 10], [11, 12, 13, 14, 15], [16, 17, 18, 19, 20, 21], [22, 23, 24, 25, 26, 27, 28]];
);

-- Cartas válidas
-- Atualiza o conjunto de cartas que são válidas para jogar
public updateValidDeck() == (
	for i = 1 to 7 do (
		for j = 1 to i do (
			if checkValidCard(i, j)
				then validDeck := [pyramidDeck(i)(j)] ^ validDeck;
		);
	);
	for i = 1 to len auxDeck do (
		if i < 3 
			then validDeck := [auxDeck(i)] ^ validDeck;
	);
);

-- Verifica se a carta é válida para ser jogada
public checkValidCard: nat1 * nat1 ==> bool
	checkValidCard(i, j) == (
		if pyramidDeck(i)(j) = 0
			then return false
		else if i = 7
			then return true
		else if pyramidDeck(i+1)(j) = 0 and pyramidDeck(i+1)(j+1) = 0
			then return true
		else
			return false;
);

-- Baralho auxiliar
-- Retira carta para deck auxiliar
public getAuxCard() ==
(	
	dcl value: nat1 := getCard(deck);
	auxDeck := [value] ^ auxDeck;
	updateValidDeck();
	-- Mostra carta
	Utils`printStatus();
);

-- Jogar
-- Seleção de carta pelo utilizador
public selectedCard: nat * nat1 ==> bool
	selectedCard(i, j) == (
		for counter = 1 to len validDeck do (
			if i = 0 and auxDeck(j) = validDeck(counter) or i <> 0 and pyramidDeck(i)(j) = validDeck(counter)
				then (selected := selected + Utils`cardToPoints(validDeck(counter));
							selectedCards:= [[i,j]] ^ selectedCards;					
							return true;)
		);
		return false;
);


-- Atualiza estado de jogo
public updateGame: () ==> bool
	updateGame() == (
		if selected = 13
			then (calcScore(); removeSelectedCards(); selected := 0; return true;)
		else if selected > 13
			then (selectedCards := []; selected := 0; return true;) 
		else return false;  
);

-- Traduz regras em pontos
public combo: () ==> nat
	combo() == (
		if (len selectedCards > 2)
			then return ((len selectedCards - 2) * 10)
		else
			 return 0
);

-- Pontos bónus
public bonus: () ==> nat
	bonus() == (
		if (bonusPyramidDeck and len pyramidDeck = 0)
			then (bonusPyramidDeck := false; return 50;) 
		else if (bonusDeck and len deck = 0)
			then (bonusDeck := false; return 30;) 
		else
			 return 0
);

-- Calcula score
public calcScore: () ==> ()
	calcScore() == (
		score := score + ((len selectedCards) * 10) + combo() + bonus();
);

-- Verifica se jogo termina
public isFinished: () ==> bool
	isFinished() == (
		if len pyramidDeck = 0 and len auxDeck = 0
			then return true
		else
			return false;
	);


-- Conversão para score
pure public static getPoints: (nat1) ==> nat1
	getPoints(num) == (
		dcl x: nat := num mod 13;
		if x = 0
			then return 13
		else
			 return x;
);


-- Retira carta (passada como argumento) do deck inicial
public getCard: DeckType ==> nat1
	getCard(deckToGet) == (
		dcl position: nat1 := new MATH().rand(len deckToGet) + 1;
		deck := removeCard(deckToGet, position);
		return deckToGet(position);
);

-- Remover carta de baralho	
public removeCard: DeckType * nat1 ==> DeckType
	removeCard(deckToRemove, position) == (
		return deckToRemove(1, ... , position - 1) ^ deckToRemove(position + 1, ... , len deck);
);

-- Desseleciona carta
public deselectCard: seq of NaturalsNums * nat1 * nat * nat1 ==> ()
	deselectCard(deckToRemove, position, y, x) == (
		selectedCards := deckToRemove(1, ... , position - 1) ^ deckToRemove(position + 1, ... , len selectedCards);
		if y = 0 then selected := selected + Utils`cardToPoints(auxDeck(x))
		else selected := selected + Utils`cardToPoints(pyramidDeck(y)(x));
);

-- Remove cartas selecionadas
public removeSelectedCards: () ==> ()
	removeSelectedCards() == (
		for i = 1 to len selectedCards do (
			if selectedCards(i) = [0,1]
				then auxDeck := tl auxDeck
			else if selectedCards(i) = [0,2]
				then auxDeck := [auxDeck(1)] ^ auxDeck(3, ..., len auxDeck)
			else
				pyramidDeck(selectedCards(i)(1))(selectedCards(i)(2)) := 0;
		);
);
	
	
functions

-- Sum Set from structure to single value
-- http://kurser.iha.dk/eit/tivdm1/Quick_Overview_of_VDM_Operators.pdf
public SumSet: set of nat -> nat
	SumSet(s) == (
		if s = {}
			then 0
		else let e in set s
					in
						getPoints(e) + SumSet(s\{e})
	);
	
traces
-- TODO Define Combinatorial Test Traces here
end Pyramid