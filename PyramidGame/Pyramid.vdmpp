class Pyramid
types
	public CardNumber = nat1
	   inv n == n <= 52;
	public DeckType = seq of nat1;
	public String = seq of char;
values
-- TODO Define values here
instance variables
	public deck: seq of CardNumber := [];
	public pyramidDeck: seq of seq of CardNumber := [];
	public auxDeck: seq of CardNumber := [];
	public cardFigLabels: seq of String := ["A", "2", "3", "4", "5", "6", "7", "8", "9", "10", "J", "Q", "K"];
	public cardSuitLabels: String := ['s', 'h', 'd', 'c'];
	
	-- Para uso do power set
	private static setExample: set of nat := {};
	
	
operations


public test() ==
(	
	createDeck();
	createPyramidDeck();
	--IO`print(self); 
);

 -- Cria deck inicial
public createDeck() ==
(
	deck := [ i | i in set {1, ..., 52}];
	
);	

-- aceder
/*	for counter = 1 to 3
		do (
			for counter2 = 1 to counter 
				do (		
						IO`print(pyramidDeck(counter)(counter2));
						);
			IO`print("\n");
			);
*/				
-- introduzir
/*	for counter = 1 to 3
		do (
				deck := [counter] ^ deck;
			);
			
	for counter = 1 to 3
		do (
				IO`print(deck(counter));
			);
	*/	

-- Cria a Piramide de Cartas
public createPyramidDeck() ==
(	
	for counter = 0 to 6
		do (
			dcl aux : seq of nat1 := [];
			for counter2 = 0 to counter 
				do (
						dcl value: nat1 := getCard(deck);
						aux := [value] ^ aux;
									
						);
				pyramidDeck := pyramidDeck ^ [aux];
			);
			printPyramid();
			
			getAuxCard();
			printAuxCards();
					
		--	IO`print(getPoints(24));
);

-- Retira carta do deck auxiliar
public getAuxCard() ==
(	
	dcl value: nat1 := getCard(deck);
	auxDeck := [value] ^ auxDeck;
);

-- Remove carta passada como argumento do deck inicial
public getCard: (DeckType) ==> nat1
	getCard(deckToGet) == (
		dcl position: nat1 := new MATH().rand(len deckToGet) + 1;
		deck := removeCard(deckToGet, position);
		return deckToGet(position);
);
	
public removeCard: DeckType * nat1 ==> DeckType
	removeCard(deckToRemove, position) == (
		return deckToRemove(1, ... , position - 1) ^ deckToRemove(position + 1, ... , len deck);
);


-- Pesquisar se existem as condições necessárias para o jogo continuar
--	- Existir jogadas válias
public continueGame: () ==> bool
	continueGame() == (		
		dcl sumCombination : nat := 0;
		IO`print(power setExample); -- listas das combinações possiveis
	
		-- Combina os elementos da lista exemplo e soma cada sublista
		for all value in set power setExample
			do ( 
					IO`print("\nCombinação possível: "); 
					IO`print(value);
					IO`print(", Soma: "); 
				  sumCombination := SumSet(value);
					IO`print(sumCombination);
					
					if sumCombination >= 13
						then return true;
				 );
			return false;
);


public printPyramid: () ==> ()
	printPyramid() == (
		for counter = 1 to 7
			do (
				for counter2 = 1 to counter 
					do (		
							IO`print(convertNumberToSuit(pyramidDeck(counter)(counter2)));
							IO`print(" ");
							);
				IO`print("\n");
			);
);

public printAuxCards: () ==> ()
	printAuxCards() == (
		dcl numCardToPrint: nat := 0;
		if len auxDeck >= 2
			then numCardToPrint := 2
		else 
			numCardToPrint := len auxDeck;
		
		for counter = 1 to numCardToPrint		
			do (
				IO`print(convertNumberToSuit(auxDeck(counter)));
				IO`print(" ");
			);
);
	
-- Conversões para visualização
public convertNumberToSuit: (nat1) ==> String
	convertNumberToSuit(num) == (
		return getFig(num) ^ [getSuit(num)]; 
	);
	
public getSuit: (nat1) ==> char
	getSuit(num) == (
		if num >= 1 and num <= 13
			then return cardSuitLabels(1)
		else if num >= 14 and num <= 26
			then return cardSuitLabels(2)
		else if num >= 27 and num <= 39
			then return cardSuitLabels(3)
		else
			return cardSuitLabels(4);
	);


public getFig: (nat1) ==> String
	getFig(num) == (
		dcl x: nat := num mod 13;
		if x = 0
			then return "K"
		else
			 return cardFigLabels(x);
	);
	
-- Conversão para score
public getPoints: (nat1) ==> nat1
	getPoints(num) == (
			return num mod 13;
);
	
	
functions

-- Sum Set from structure to single value
-- http://kurser.iha.dk/eit/tivdm1/Quick_Overview_of_VDM_Operators.pdf
public SumSet: set of nat -> nat
	SumSet(s) == (
		if s = {}
			then 0
		else let e in set s
					in
						e + SumSet(s\{e})
	);

	
traces
-- TODO Define Combinatorial Test Traces here
end Pyramid